# ButterQuant 机器学习系统完整技术文档

**版本**: v2.0 Final  
**最后更新**: 2025-01-19  
**目标**: 基于历史回测的深度学习训练系统

---

## 📋 目录

1. [系统现状诊断](#1-系统现状诊断)
2. [核心问题与解决方案](#2-核心问题与解决方案)
3. [技术架构](#3-技术架构)
4. [实施方案](#4-实施方案)
5. [代码实现](#5-代码实现)
6. [验证与部署](#6-验证与部署)

---

## 1. 系统现状诊断

### 1.1 已完成的架构

你的系统已建立完整的 ML 流水线：

```
数据采集 → 特征工程 → 模型训练 → ONNX部署 → 实时推理 → 自动交易
   ↓           ↓          ↓          ↓          ↓          ↓
scanner → features → train_model → export → inference → execution
```

**工程优势**:
- ✅ 使用单例模式的推理引擎
- ✅ ONNX Runtime 优化 (支持 CUDA)
- ✅ 双轨制设计 (AI Track + Baseline Track)
- ✅ 完整的数据库记录

### 1.2 三大致命缺陷

#### ⚠️ 缺陷 1: 评估时间尺度错配

**当前逻辑**:
```python
# features.py
horizon = 1  # 仅用1天后的价格标注
is_success = 1 if lower_strike <= price_future <= upper_strike else 0
```

**问题分析**:
- Butterfly 策略持有期: 30-45 天
- 1天评估点: 仅衰减 2-3% 时间价值
- 真正盈利期: DTE 剩余 5-7 天时

**实际影响**:
```
DTE=45天建仓, 1天后评估:
  - 时间价值衰减: 仅 2.2%
  - 标签: 70% 被标记为"失败"
  - 实际: 这些策略在成熟期可能盈利 20-30%

模型学到的是: "如何预测1天后的噪音"
而不是: "策略是否会在到期时盈利"
```

#### ⚠️ 缺陷 2: 数据泄露 (Data Leakage)

**问题特征**:
```python
# features.py
features = {
    ...
    'total_score': score.get('total', 0)  # ❌ 这是策略评估结果
}
```

**风险**:
- `total_score` 是 `ButterflyAnalyzer` 综合判断的输出
- ML 模型在"用答案预测答案"
- 当 `total_score` 公式失效时，ML 也同步崩溃

#### ⚠️ 缺陷 3: 反馈闭环缺失

**当前状态**:
```
[一次性训练]
历史数据 → 训练模型 → success_model.onnx
                           ↓
                    [部署后静态不变]
                           ↓
[生产环境]                  
新数据 → 推理 → 交易 → 结果 → ❌ 未回流到训练
```

**问题**:
- 市场环境变化 (Concept Drift) 无法被捕获
- 模型性能逐月衰减
- 无法量化 ML 的实际价值

---

## 2. 核心问题与解决方案

### 2.1 问题汇总表

| 问题 | 当前状态 | 改进方案 | 优先级 |
|------|---------|---------|--------|
| 评估时间点 | 固定 1 天 | 动态 DTE-5 天 | 🔴 P0 |
| 标注标准 | 价格在区间 | 实际 ROI > 阈值 | 🔴 P0 |
| 数据泄露 | 包含 total_score | 移除并增加新特征 | 🟡 P1 |
| 训练数据量 | ~5000 条 | 生成 20,000+ 条 | 🔴 P0 |
| 市场覆盖 | 单一环境 | VIX 分层采样 | 🟡 P1 |
| 反馈闭环 | 缺失 | 月度重训机制 | 🟢 P2 |

### 2.2 技术决策

#### 决策 1: 动态评估时间

**旧逻辑**: 固定 14 天后评估  
**新逻辑**: 评估时点 = 建仓日期 + (DTE - 5天)

```python
def calculate_evaluation_date(analysis_date, dte):
    if dte >= 30:
        days_to_eval = dte - 5  # 到期前5天
    else:
        days_to_eval = max(dte - 3, int(dte * 0.8))
    
    return analysis_date + timedelta(days=days_to_eval)
```

**示例**:
- DTE=30天 → 25天后评估 (剩余5天时)
- DTE=45天 → 40天后评估 (剩余5天时)

#### 决策 2: 4分类多任务学习

**从二分类改为四分类**:
```python
ROI分级:
  Class 0: 亏损   (ROI < -10%)
  Class 1: 微利   (-10% ≤ ROI < 5%)
  Class 2: 良好   (5% ≤ ROI < 15%)
  Class 3: 优秀   (ROI ≥ 15%)
```

**执行逻辑**:
```python
# 计算期望ROI
E[ROI] = p₀×0 + p₁×0.05 + p₂×0.20 + p₃×0.40

# 执行条件
if E[ROI] > 0.15:  # 期望ROI > 15%
    execute_trade()
```

#### 决策 3: 扩展特征集

**移除**: `total_score` (数据泄露)

**新增 6 个特征**:
```python
1. skew_estimate: IV偏度估计
2. momentum_7d: 7日价格动量
3. vol_concentration: 成交量集中度
4. dte_factor: DTE归一化因子
5. price_stability: 价格稳定性
6. gamma_theta_ratio: Gamma/Theta比率
```

**最终**: 23维特征向量

---

## 3. 技术架构

### 3.1 数据生成流程

```
┌─────────────────────────────────────────────────┐
│ Phase 1: VIX分层采样                             │
└─────────────────────────────────────────────────┘
                    ↓
    下载VIX历史数据 (2023-01-01 ~ 2025-01-31)
                    ↓
    ┌──────────────────────────────────────┐
    │ 低波期 (VIX<15):   2000样本 (40天×50) │
    │ 常态期 (15≤VIX≤25): 3000样本 (60天×50) │
    │ 高波期 (VIX>25):   2000样本 (40天×50) │
    └──────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────┐
│ Phase 2: 历史模拟分析                            │
└─────────────────────────────────────────────────┘
                    ↓
    For each sampled_date:
      1. 获取Top 50标的
      2. 获取截至该日期的历史价格
      3. 运行ButterflyAnalyzer (as-of分析)
      4. 计算IV Proxy (Moneyness调整)
      5. 提取23维特征
      6. 前向 (DTE-5天) 获取实际价格
      7. 计算ROI并标注 (0/1/2/3)
                    ↓
    输出: training_data_deep.parquet (~7000样本)
```

### 3.2 IV Proxy 计算

**问题**: 历史上没有真实的期权链数据

**解决方案**: 基于 Moneyness 调整历史波动率

```python
def get_iv_proxy(strike, spot, hv):
    moneyness = strike / spot
    
    if moneyness < 0.95:
        multiplier = 1.25  # OTM Put (恐慌溢价)
    elif moneyness > 1.05:
        multiplier = 1.10  # OTM Call (投机折扣)
    else:
        multiplier = 1.15  # ATM (基准)
    
    return hv * multiplier
```

**理论依据**:
- OTM Put 需求高 (保护性买入) → IV溢价
- ATM 流动性最好 → IV接近HV
- OTM Call 投机需求弱 → IV折扣

### 3.3 ROI 计算逻辑

```python
def calculate_butterfly_roi(future_price, lower, center, upper, cost, max_profit):
    """
    蝴蝶策略ROI计算
    
    Payoff函数:
      - 区间外: -cost (损失全部成本)
      - 左翼: max_profit × (price - lower) / (center - lower)
      - 右翼: max_profit × (upper - price) / (upper - center)
    """
    if lower <= future_price <= upper:
        if future_price <= center:
            payoff = max_profit * (future_price - lower) / (center - lower)
        else:
            payoff = max_profit * (upper - future_price) / (upper - center)
    else:
        payoff = -cost
    
    roi = payoff / cost if cost > 0 else -1.0
    return roi
```

---

## 4. 实施方案

### 4.1 文件修改清单

| 文件 | 操作 | 关键改动 |
|------|------|---------|
| `ml/features.py` | MODIFY | 移除 total_score, 新增6个特征 |
| `ml/train_model.py` | MODIFY | 改为4分类, 增加类别权重 |
| `ml/ml_inference.py` | MODIFY | 输出4维概率, 计算期望ROI |
| `ml/generate_simulated_data.py` | NEW | 历史回测数据生成器 |
| `backend/execution_engine.py` | MODIFY | 使用期望ROI决策 |

### 4.2 实施步骤

#### Step 1: 生成训练数据 (2-3小时)

```bash
python ml/generate_simulated_data.py
```

**输出**: `ml/training_data_deep.parquet`
- 约 7000 条样本
- 23 维特征
- 4 分类标签

#### Step 2: 训练模型 (3分钟 on RTX 4060)

```bash
python ml/train_model.py
```

**输出**:
- `ml/success_model_v2.onnx` (ONNX模型)
- `ml/scaler_v2.pkl` (特征缩放器)
- `ml/confusion_matrix.png` (混淆矩阵)
- `ml/training_curves.png` (训练曲线)

#### Step 3: 验证推理引擎

```bash
python ml/ml_inference.py
```

**检查**:
- ONNX加载成功
- 期望ROI计算正确
- 性能 < 2ms/样本

#### Step 4: 集成到执行引擎

修改 `backend/execution_engine.py`:

```python
from ml.ml_inference import get_inference_engine

ml_engine = get_inference_engine()

# AI Track逻辑
for candidate in all_candidates:
    result = ml_engine.predict_roi_distribution(features)
    
    if result['expected_roi'] > 0.15:  # 期望ROI > 15%
        ai_candidates.append({
            **candidate,
            'expected_roi': result['expected_roi']
        })
```

---

## 5. 代码实现

### 5.1 特征工程 (features.py)### 5.2 数据生成器 (generate_simulated_data.py)### 5.3 推理引擎 (ml_inference.py)---

## 6. 验证与部署

### 6.1 验证清单

#### 第一步: 数据质量验证

```bash
# 生成数据后检查
python -c "
import pandas as pd
df = pd.read_parquet('ml/training_data_deep.parquet')
print(f'总样本数: {len(df)}')
print(f'标签分布:\\n{df[\"label\"].value_counts(normalize=True)}')
print(f'ROI统计: 均值={df[\"_debug_roi\"].mean():.2%}')
"
```

**预期输出**:
```
总样本数: 6000+
标签分布:
  0: 25-35%  (亏损)
  1: 30-40%  (微利)
  2: 20-25%  (良好)
  3: 10-15%  (优秀)
ROI统计: 均值=5-15%
```

#### 第二步: 模型性能验证

训练完成后检查:
```bash
cat ml/training_log.txt | grep "Test"
```

**预期指标**:
- Overall Accuracy > 45% (随机为25%)
- Macro F1 > 0.40
- 混淆矩阵对角线明显高于非对角线

#### 第三步: 推理性能测试

```bash
python ml/ml_inference.py
```

**预期性能**:
- 平均延迟 < 2ms/样本
- 吞吐量 > 500 样本/秒 (CPU) 或 > 1500 样本/秒 (GPU)

### 6.2 部署步骤

#### 第一步: 备份旧模型

```bash
cd ml
mkdir -p models_backup_$(date +%Y%m%d)
cp success_model*.onnx scaler*.pkl models_backup_*/
```

#### 第二步: 部署新模型

```bash
# 已由train_model.py自动生成
ls -lh ml/success_model_v2.onnx
ls -lh ml/scaler_v2.pkl
```

#### 第三步: 集成到execution_engine

修改 `backend/execution_engine.py`:

```python
from ml.ml_inference import get_inference_engine

class ExecutionEngine:
    def __init__(self):
        # ... 原有代码 ...
        self.ml_engine = get_inference_engine()
    
    def run_daily_execution(self):
        # ... 前面代码不变 ...
        
        # AI Track逻辑改为期望ROI
        ai_candidates = []
        for candidate in all_candidates:
            features = self._extract_features(candidate)
            ml_result = self.ml_engine.predict_roi_distribution(features)
            
            if ml_result and ml_result['expected_roi'] > 0.15:
                ai_candidates.append({
                    **candidate,
                    'expected_roi': ml_result['expected_roi'],
                    'prob_excellent': ml_result['prob_excellent'],
                    'ml_confidence': ml_result['confidence']
                })
        
        # 按期望ROI排序
        sorted_ai_list = sorted(
            ai_candidates,
            key=lambda x: x['expected_roi'],
            reverse=True
        )
        
        logger.info(f"🤖 [AI Track] {len(sorted_ai_list)} 个机会 (期望ROI>15%)")
        self._execute_batch(sorted_ai_list[:5], current_symbol_set, 'AI')
```

#### 第四步: 重启服务

```bash
# 如果使用systemd
sudo systemctl restart butterquant

# 或直接运行
python backend/execution_engine.py
```

### 6.3 监控与反馈

#### 性能监控脚本

创建 `monitor_ml_performance.py`:

```python
import pandas as pd
from datetime import datetime, timedelta

def monitor_ml_performance():
    """监控ML预测准确率"""
    
    # 获取最近30天的已平仓交易
    db = DatabaseEngine()
    trades = db.execute_query("""
        SELECT 
            order_ref,
            ticker,
            ml_predicted_roi,
            actual_pnl,
            entry_date
        FROM trades
        WHERE status = 'CLOSED'
        AND entry_date >= ?
        AND order_ref LIKE 'AI%'
    """, (datetime.now() - timedelta(days=30),))
    
    if not trades:
        print("暂无数据")
        return
    
    df = pd.DataFrame(trades)
    
    # 计算准确率
    df['predicted_success'] = df['ml_predicted_roi'] > 0.15
    df['actual_success'] = df['actual_pnl'] > 0
    
    accuracy = (df['predicted_success'] == df['actual_success']).mean()
    
    print(f"📊 ML 30天准确率: {accuracy:.2%}")
    print(f"   预测成功: {df['predicted_success'].sum()} 笔")
    print(f"   实际成功: {df['actual_success'].sum()} 笔")
    
    # 期望ROI vs 实际ROI
    expected_roi = df['ml_predicted_roi'].mean()
    actual_roi = (df['actual_pnl'] / df['entry_cost']).mean()
    
    print(f"\n   期望ROI: {expected_roi:.2%}")
    print(f"   实际ROI: {actual_roi:.2%}")
    print(f"   偏差: {abs(expected_roi - actual_roi):.2%}")

if __name__ == "__main__":
    monitor_ml_performance()
```

定期运行:
```bash
# 每周一运行
0 9 * * 1 /usr/bin/python3 /path/to/monitor_ml_performance.py
```

---

## 7. 常见问题与解决

### Q1: 训练数据生成太慢怎么办?

**优化方案**:
1. 减少采样天数 (如改为 20/30/20 天)
2. 减少每天的标的数量 (如改为 30 只)
3. 使用多进程并行下载

### Q2: 模型准确率过低 (<40%)?

**排查步骤**:
1. 检查标签分布是否极度不平衡
2. 检查特征是否包含大量NaN/Inf
3. 增加训练数据量
4. 调整类别权重

### Q3: 推理速度过慢 (>5ms)?

**优化方案**:
1. 确认使用了ONNX Runtime
2. 启用GPU加速 (安装onnxruntime-gpu)
3. 使用批量推理
4. 减少特征数量

### Q4: 期望ROI预测偏差大?

**可能原因**:
1. 评估时间点设置不当
2. IV Proxy不准确
3. 市场环境变化 (Concept Drift)

**解决方案**:
- 重新训练模型 (使用最新数据)
- 调整评估时间点
- 实施反馈闭环机制

---

## 8. 后续优化方向

### 8.1 短期优化 (1-2周)

1. **A/B测试框架**
   - 20% 流量使用新模型
   - 80% 流量使用旧模型
   - 对比实际表现

2. **性能监控仪表板**
   - 实时准确率追踪
   - ROI预测偏差监控
   - 自动告警机制

### 8.2 中期优化 (1-2月)

1. **反馈闭环**
   - 每月重新训练
   - 使用最新交易结果
   - 动态调整阈值

2. **特征工程增强**
   - 引入波动率曲面特征
   - 增加宏观经济指标
   - 市场情绪指标

### 8.3 长期优化 (3-6月)

1. **多任务学习**
   - 同时预测成功率和最大回撤
   - 动态仓位管理

2. **强化学习**
   - 从实盘交易中持续学习
   - 自适应策略优化

---

## 9. 总结

### 核心改进

| 维度 | 改进前 | 改进后 |
|------|--------|--------|
| 评估时间 | 固定1天 | 动态DTE-5天 |
| 标注逻辑 | 价格在区间 | 实际ROI分级 |
| 训练数据 | ~5000条 | ~7000条 |
| 特征集 | 17维 (含泄露) | 23维 (无泄露) |
| 模型输出 | 二分类概率 | 4分类+期望ROI |
| 执行决策 | 固定阈值 | 期望ROI优化 |

### 预期效果

- **准确率提升**: 从 ~30% → 45-55%
- **ROI预测**: 偏差从 ±30% → ±15%
- **策略胜率**: 从 ~25% → 35-45%
- **系统可维护性**: 可持续优化

---

**文档版本**: v2.0 Final  
**最后更新**: 2025-01-19  
**维护者**: ButterQuant Team