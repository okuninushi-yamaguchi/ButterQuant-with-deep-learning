# trading/ibkr_trader.py
"""
盈透证券 Paper Trading 集成
需要安装：pip install ib_insync
"""

from ib_insync import IB, Stock, Option, MarketOrder, util
from datetime import datetime, timedelta
import pandas as pd
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class IBKRTrader:
    """
    盈透证券交易接口
    支持双账户（Baseline + RL）
    """
    
    def __init__(self, account_type='baseline', port=7497):
        """
        初始化
        
        参数:
            account_type: 'baseline' 或 'rl'
            port: TWS/IB Gateway 端口
                  7497 = Paper Trading
                  7496 = Live Trading（真实账户，谨慎！）
        """
        self.account_type = account_type
        self.ib = IB()
        self.port = port
        self.client_id = 1 if account_type == 'baseline' else 2
        
        # 连接到 TWS
        self.connect()
    
    def connect(self):
        """连接到 IB Gateway"""
        try:
            self.ib.connect('127.0.0.1', self.port, clientId=self.client_id)
            logger.info(f"✅ 已连接到盈透 ({self.account_type} 账户)")
            
            # 打印账户信息
            account_values = self.ib.accountValues()
            nav = [v for v in account_values if v.tag == 'NetLiquidation'][0]
            logger.info(f"   账户净值：${nav.value}")
            
        except Exception as e:
            logger.error(f"❌ 连接失败：{e}")
            raise
    
    def disconnect(self):
        """断开连接"""
        self.ib.disconnect()
        logger.info(f"已断开盈透连接 ({self.account_type})")
    
    def get_stock_price(self, ticker):
        """获取股票实时价格"""
        stock = Stock(ticker, 'SMART', 'USD')
        self.ib.qualifyContracts(stock)
        
        ticker_obj = self.ib.reqMktData(stock, '', False, False)
        self.ib.sleep(1)  # 等待数据
        
        return ticker_obj.marketPrice()
    
    def get_option_chain(self, ticker, expiry_days=30):
        """
        获取期权链
        
        参数:
            ticker: 股票代码
            expiry_days: 到期天数（默认30天）
        
        返回:
            DataFrame with columns: strike, right, bid, ask, impliedVol
        """
        stock = Stock(ticker, 'SMART', 'USD')
        self.ib.qualifyContracts(stock)
        
        # 获取期权链
        chains = self.ib.reqSecDefOptParams(stock.symbol, '', stock.secType, stock.conId)
        
        if not chains:
            logger.error(f"未找到 {ticker} 的期权链")
            return None
        
        chain = chains[0]
        
        # 筛选到期日（距离当前 expiry_days 天）
        target_date = datetime.now() + timedelta(days=expiry_days)
        expirations = sorted(chain.expirations)
        expiry = min(expirations, key=lambda x: abs(
            datetime.strptime(x, '%Y%m%d') - target_date
        ).days)
        
        logger.info(f"选择到期日：{expiry}")
        
        # 获取所有行权价
        strikes = sorted(chain.strikes)
        
        # 获取期权报价
        options_data = []
        for strike in strikes:
            for right in ['C', 'P']:
                option = Option(ticker, expiry, strike, right, 'SMART')
                self.ib.qualifyContracts(option)
                
                ticker_obj = self.ib.reqMktData(option, '', False, False)
                self.ib.sleep(0.5)
                
                options_data.append({
                    'strike': strike,
                    'right': right,
                    'bid': ticker_obj.bid,
                    'ask': ticker_obj.ask,
                    'last': ticker_obj.last,
                    'impliedVol': ticker_obj.impliedVolatility,
                    'volume': ticker_obj.volume,
                    'openInterest': ticker_obj.openInterest
                })
        
        return pd.DataFrame(options_data)
    
    def execute_butterfly(self, ticker, strategy_result, quantity=1):
        """
        执行蝴蝶期权交易
        
        参数:
            ticker: 股票代码
            strategy_result: analyzer.py 的策略结果
            quantity: 交易数量（1 = 1手蝴蝶）
        
        返回:
            {
                'order_ids': [id1, id2, id3],
                'total_cost': float,
                'status': 'Filled' | 'Pending' | 'Failed'
            }
        """
        strategy = strategy_result['butterfly_strategy']
        expiry = strategy['expiry']
        
        # 构建 3 个期权合约
        lower_strike = strategy['lower_strike']
        center_strike = strategy['center_strike']
        upper_strike = strategy['upper_strike']
        
        if strategy['type'] == 'CALL':
            # Call Butterfly
            leg1 = Option(ticker, expiry, lower_strike, 'C', 'SMART')
            leg2 = Option(ticker, expiry, center_strike, 'C', 'SMART')
            leg3 = Option(ticker, expiry, upper_strike, 'C', 'SMART')
        elif strategy['type'] == 'PUT':
            # Put Butterfly
            leg1 = Option(ticker, expiry, lower_strike, 'P', 'SMART')
            leg2 = Option(ticker, expiry, center_strike, 'P', 'SMART')
            leg3 = Option(ticker, expiry, upper_strike, 'P', 'SMART')
        else:  # IRON
            # Iron Butterfly（Call + Put 组合）
            leg1 = Option(ticker, expiry, upper_strike, 'C', 'SMART')  # Buy Call
            leg2_call = Option(ticker, expiry, center_strike, 'C', 'SMART')  # Sell Call
            leg2_put = Option(ticker, expiry, center_strike, 'P', 'SMART')   # Sell Put
            leg3 = Option(ticker, expiry, lower_strike, 'P', 'SMART')  # Buy Put
        
        # 验证合约
        contracts = [leg1, leg2, leg3] if strategy['type'] != 'IRON' else [leg1, leg2_call, leg2_put, leg3]
        self.ib.qualifyContracts(*contracts)
        
        # 下单
        orders = []
        
        # Leg 1: Buy
        order1 = MarketOrder('BUY', quantity)
        trade1 = self.ib.placeOrder(leg1, order1)
        orders.append(trade1)
        
        # Leg 2: Sell (2份)
        if strategy['type'] != 'IRON':
            order2 = MarketOrder('SELL', quantity * 2)
            trade2 = self.ib.placeOrder(leg2, order2)
            orders.append(trade2)
        else:
            # Iron Butterfly: Sell Call + Sell Put
            order2_call = MarketOrder('SELL', quantity)
            order2_put = MarketOrder('SELL', quantity)
            trade2_call = self.ib.placeOrder(leg2_call, order2_call)
            trade2_put = self.ib.placeOrder(leg2_put, order2_put)
            orders.extend([trade2_call, trade2_put])
        
        # Leg 3: Buy
        order3 = MarketOrder('BUY', quantity)
        trade3 = self.ib.placeOrder(leg3, order3)
        orders.append(trade3)
        
        # 等待订单执行
        self.ib.sleep(2)
        
        # 检查状态
        filled_orders = [o for o in orders if o.orderStatus.status == 'Filled']
        
        if len(filled_orders) == len(orders):
            status = 'Filled'
            total_cost = sum([o.orderStatus.avgFillPrice * o.order.totalQuantity for o in filled_orders])
            logger.info(f"✅ {ticker} 蝴蝶策略已执行，成本：${total_cost:.2f}")
        else:
            status = 'Partial' if filled_orders else 'Failed'
            total_cost = 0
            logger.warning(f"⚠️ {ticker} 蝴蝶策略部分成交或失败")
        
        return {
            'order_ids': [o.order.orderId for o in orders],
            'total_cost': total_cost,
            'status': status,
            'timestamp': datetime.now()
        }
    
    def get_positions(self):
        """获取当前持仓"""
        positions = self.ib.positions()
        
        positions_data = []
        for pos in positions:
            positions_data.append({
                'contract': pos.contract,
                'position': pos.position,
                'avgCost': pos.avgCost,
                'marketValue': pos.marketValue,
                'unrealizedPNL': pos.unrealizedPNL
            })
        
        return pd.DataFrame(positions_data)
    
    def get_pnl(self):
        """获取当日盈亏"""
        account_values = self.ib.accountValues()
        
        # 提取关键指标
        pnl_data = {}
        for v in account_values:
            if v.tag == 'UnrealizedPnL':
                pnl_data['unrealized_pnl'] = float(v.value)
            elif v.tag == 'RealizedPnL':
                pnl_data['realized_pnl'] = float(v.value)
            elif v.tag == 'NetLiquidation':
                pnl_data['net_liquidation'] = float(v.value)
        
        return pnl_data
    
    def close_position(self, contract):
        """平仓"""
        positions = self.ib.positions()
        
        for pos in positions:
            if pos.contract == contract:
                # 反向交易
                action = 'SELL' if pos.position > 0 else 'BUY'
                quantity = abs(pos.position)
                
                order = MarketOrder(action, quantity)
                trade = self.ib.placeOrder(contract, order)
                
                self.ib.sleep(1)
                
                if trade.orderStatus.status == 'Filled':
                    logger.info(f"✅ 已平仓：{contract.localSymbol}")
                    return True
                else:
                    logger.warning(f"⚠️ 平仓失败：{contract.localSymbol}")
                    return False
        
        logger.warning(f"未找到持仓：{contract.localSymbol}")
        return False


# ==================== 使用示例 ====================
def example_usage():
    """示例：双账户交易"""
    
    # 初始化两个账户
    baseline_trader = IBKRTrader('baseline', port=7497)
    rl_trader = IBKRTrader('rl', port=7497)
    
    # 获取分析结果
    from analyzer import ButterflyAnalyzer
    analyzer = ButterflyAnalyzer('AAPL')
    
    # Baseline 账户：固定权重
    baseline_result = analyzer.full_analysis(weights=[35, 30, 20, 15])
    
    # RL 账户：动态权重（从 RL 模型获取）
    from ml.bayesian_optimizer import PolicyGradientAgent
    agent = PolicyGradientAgent()
    state = baseline_trader.ib.accountValues()  # 简化：用账户状态作为 state
    action = agent.select_action(state)
    rl_result = analyzer.full_analysis(weights=action['weights'])
    
    # 执行交易
    if baseline_result['total_score'] > 70:
        baseline_trader.execute_butterfly('AAPL', baseline_result)
    
    if rl_result['total_score'] > 70:
        rl_trader.execute_butterfly('AAPL', rl_result)
    
    # 查看持仓
    print("Baseline 持仓：")
    print(baseline_trader.get_positions())
    
    print("\nRL 持仓：")
    print(rl_trader.get_positions())
    
    # 查看盈亏
    print("\nBaseline P&L：", baseline_trader.get_pnl())
    print("RL P&L：", rl_trader.get_pnl())
    
    # 断开连接
    baseline_trader.disconnect()
    rl_trader.disconnect()


if __name__ == '__main__':
    example_usage()