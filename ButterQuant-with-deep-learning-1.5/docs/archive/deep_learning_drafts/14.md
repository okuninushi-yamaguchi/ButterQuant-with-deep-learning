# backend/app.py - 添加内存缓存（零成本优化）

import time
from functools import lru_cache
from flask import Flask, request, jsonify
from flask_cors import CORS
import yfinance as yf

app = Flask(__name__)
CORS(app)

# ==================== 缓存层 ====================
CACHE = {}
CACHE_TTL = 300  # 5分钟缓存（根据市场开盘时间调整）

def get_cache_key(ticker, analysis_type='full'):
    """生成缓存键"""
    return f"{ticker.upper()}:{analysis_type}"

def get_cached_result(cache_key):
    """检查缓存"""
    if cache_key in CACHE:
        cached_time, result = CACHE[cache_key]
        if time.time() - cached_time < CACHE_TTL:
            return result, True  # 返回结果 + 缓存标记
    return None, False

def set_cache(cache_key, result):
    """存入缓存"""
    CACHE[cache_key] = (time.time(), result)
    
    # 自动清理过期缓存（避免内存泄漏）
    if len(CACHE) > 100:  # 超过100条自动清理
        current_time = time.time()
        expired_keys = [k for k, v in CACHE.items() if current_time - v[0] > CACHE_TTL]
        for k in expired_keys:
            del CACHE[k]

# ==================== 优化的数据获取 ====================
@lru_cache(maxsize=50)  # LRU缓存最近50只股票的基础数据
def get_stock_data(ticker, period='2y'):
    """获取股票历史数据（带缓存）"""
    stock = yf.Ticker(ticker)
    return stock.history(period=period)

# ==================== API路由 ====================
@app.route('/api/analyze', methods=['POST'])
def analyze():
    """主分析接口"""
    try:
        ticker = request.json.get('ticker', 'AAPL').upper()
        
        # 1. 检查缓存
        cache_key = get_cache_key(ticker, 'full')
        cached_result, is_cached = get_cached_result(cache_key)
        
        if is_cached:
            return jsonify({
                'success': True,
                'data': cached_result,
                'from_cache': True,
                'cache_age': int(time.time() - CACHE[cache_key][0])  # 缓存年龄（秒）
            })
        
        # 2. 执行分析（你的原有逻辑）
        from analyzer import ButterflyAnalyzer
        analyzer = ButterflyAnalyzer(ticker)
        result = analyzer.full_analysis()
        
        # 3. 存入缓存
        set_cache(cache_key, result)
        
        return jsonify({
            'success': True,
            'data': result,
            'from_cache': False
        })
        
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/quick-quote', methods=['POST'])
def quick_quote():
    """快速报价接口（仅返回当前价格+IV，不做完整分析）"""
    ticker = request.json.get('ticker', 'AAPL').upper()
    cache_key = get_cache_key(ticker, 'quote')
    
    cached_result, is_cached = get_cached_result(cache_key)
    if is_cached:
        return jsonify({'success': True, 'data': cached_result, 'from_cache': True})
    
    # 快速获取基础信息
    stock = yf.Ticker(ticker)
    info = stock.info
    result = {
        'current_price': info.get('currentPrice'),
        'implied_volatility': info.get('impliedVolatility'),
        'volume': info.get('volume')
    }
    
    set_cache(cache_key, result)
    return jsonify({'success': True, 'data': result})

@app.route('/api/cache/stats', methods=['GET'])
def cache_stats():
    """缓存统计（调试用）"""
    current_time = time.time()
    stats = {
        'total_entries': len(CACHE),
        'valid_entries': sum(1 for v in CACHE.values() if current_time - v[0] < CACHE_TTL),
        'expired_entries': sum(1 for v in CACHE.values() if current_time - v[0] >= CACHE_TTL)
    }
    return jsonify(stats)

@app.route('/api/cache/clear', methods=['POST'])
def clear_cache():
    """手动清空缓存"""
    CACHE.clear()
    get_stock_data.cache_clear()  # 清空 LRU 缓存
    return jsonify({'success': True, 'message': 'Cache cleared'})

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)